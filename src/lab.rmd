---
title: Grilled Cheese Experiment
output:
  html_document: default
  pdf_document: default
---
## Section I: Introduction and Literature Review

```{r imports, echo=FALSE, results='hide', message=FALSE}
library(magick)
library(tesseract)
library(knitr)
library(dplyr)
library(pander)
library(purrr)
library(tidyverse)
library(svglite)
library(yaml)
library(df2yaml)
library(tidyr)
```

### A
```{r include=FALSE}
# Summarize how at least two reference materials relate to the basic scientific principles of your experiment. Each reference material must come from a different source. Be sure to describe how the references provide a foundational background for the experiment you will conduct.
```

## Section II: Hypothesis

### B

```{r include=FALSE}
# Make a hypothesis(es) to predicit the effect of a manipulation of an independent variable on a quantitative dependent variable.
```

### C

```{r include=FALSE}
# Justify your hypothesis(es) based on prior research and known scientific principles.
```

## Section III: Method

### D
```{r include=FALSE}
# Describe the independent variable(s); include the following information:
# * a description of how the variable(s) will be manipulated
# * description of experimental conditions, if applicable
```

#### Grid
```{r grid}
oils = character(0)
oils_short = character(0)

# explicitly assigning numbers so the assignments never change
oils[1] = "Light Butter"
oils_short[1] = "LB"

oils[2] = "Light Mayo"
oils_short[2] = "LM"

oils[3] = "None"
oils_short[3] = "X"

oils[4] = "Heavy Butter"
oils_short[4] = "HB"

oils[5] = "Heavy Mayo"
oils_short[5] = "HM"

pander(matrix(oils_short, ncol=6, nrow=5, byrow=TRUE),  split.table=Inf)

grid <- data.frame(
  x = rep(1:6, times=5),
  y = rep(1:5, each=6),
  oil_num = rep(1:5)
)

grid <- mutate(grid,
  oil = oils[oil_num],
  id = x*100 + y*10 +oil_num
)

pander(grid)
```


### E: Dependent Variables
```{r include=FALSE}
# Describe the dependent variable(s); include the following information:
# * a description of how the variable(s)will be quantified, including units of measure
# * a description of how the variable(s) will be recorded
# The dependent variable is the darkness of the bread.  This will be measured by photographing each sample in a box with a controlled light source and checking the average value of the pixels.
```

### F
```{r include=FALSE}
# Describe at least one external, confounding variable and how it will be controlled. Be sure to justify how your method of controlling that variable will mitigate any confounding effect on observed results.
```
 
### G
```{r include=FALSE}
# Describe your materials and measurement tools in enough detail that a reader would be able to replicate the experiment.
```

#### Software setup

See GitHub repository https://github.com/AaronVerDow/grilled_cheese_experiment/

#### GoPro setup

#### Image Tests

```{r options, echo=FALSE, results='hide', message=FALSE}
cache_images <- FALSE
cache_histograms <- TRUE && cache_images

# open picture in GIMP, select area, use position and size values
# (take screenshot of this)
sample_geometry <- "662x746+1564+1822"
number_geometry <- "243x1674+3372+1413"

# adjust light cutoff for rendering numbers as black and white
number_threshold <- "85%"

ocr_cache <- yaml.load_file("ocr.yaml")
```

```{r functions, echo=FALSE, results='hide', message=FALSE}

generate_sample <- function(path) {
  sample_path = tmp_path("sample", path, "png")
  if (!file.exists(sample_path)) {
    image_read(path) %>%
    process_sample_pic() %>%
    image_write(path=sample_path, format="png")
  }
  return(sample_path)
}

process_sample_pic <- function(image) {
  image <- image_crop(image, sample_geometry)

  # Add alpha channel
  pixels <- image_data(image, channels = "rgba")
  
  # Extract RGB channels
  red <- as.numeric(pixels[1,,])
  green <- as.numeric(pixels[2,,])
  blue <- as.numeric(pixels[3,,])
  
  # Calculate luminance
  gray <- 0.2126 * red + 0.7152 * green + 0.0722 * blue
  gray <- as.integer(gray)
  
  # Create a binary mask where green is the brightest channel
  mask <- (green > red) & (green > blue)
  
  # Update alpha channel where green is max
  pixels[4,,][mask] <- as.raw(0)
  
  # Update RGB channels with calculated gray value
  pixels[1,,] <- as.raw(gray)
  pixels[2,,] <- as.raw(gray)
  pixels[3,,] <- as.raw(gray)
  
  # Convert back to image
  return(image_read(pixels))
}

get_grays <- function(path) {
    # returns a vector of opaque values
    # image is assumed to be grayscale with rgba channels
    pixels <- image_read(path) %>% image_data(channels="rgba")
    gray <- as.numeric(pixels[1,,])
    alpha <- as.numeric(pixels[4,,])
    mask <- alpha != 0
    return(gray[mask])
}

get_number_pic <- function(path) {
  number <- image_read(path)
  number <- image_crop(number, number_geometry)
  number <- image_rotate(number, 90)
  number <- image_reducenoise(number)
  number <- image_modulate(number, saturation = 0)
  number <- image_threshold(number,type="white", threshold=number_threshold) 
  number <- image_threshold(number,type="black", threshold=number_threshold) 
  number <- image_negate(number)
  # target 32px for letter height
  number <- image_scale(number, "250")
  return(number)
}

get_number <- function(image) {
  # https://cran.r-project.org/web/packages/tesseract/vignettes/intro.html
  # 9 is an upside down 6
  dice <- tesseract(options = list(tessedit_char_whitelist = "1234569"))
  text = as.integer(tesseract::ocr(image, engine = dice))
  return(text)
}

tmp_path <- function(prefix, path, extension) {
  path <- basename(path)
  path <- gsub("[^/.]*$", extension, path)
  path <- paste(prefix, path, sep="_")
  return(paste("tmp", path, sep="/"))
}

get_values <- function(pic) {
  pixels <- image_data(pic, channels="rgba")
  width <- dim(pixels)[2]
  height <- dim(pixels)[3]
  avgs <- character()
  # I give up.  Just do loops
  for (y in 1:height) {
    for (x in 1:width) {
        if (pixels[4, x, y] != 0) {
          avgs <- c(avgs, as.numeric(pixels[1,x,y]))
        }
    }
  }
  return(avgs)
}


# Function to calculate luminance for each row
calculate_luminance <- function(rgb_row) {
    # Normalize RGB values to the range [0, 1]
    # R_norm <- rgb_row[1] / 255
    # G_norm <- rgb_row[2] / 255
    # B_norm <- rgb_row[3] / 255
    
    # https://support.ptc.com/help/mathcad/r10.0/en/index.html#page/PTC_Mathcad_Help/example_grayscale_and_color_in_images.html
    Y <- 0.299 * rgb_row[1] + 0.587 * rgb_row[2] + 0.114 * rgb_row[3]
    
    # Calculate luminance Y using the formula
    # Y <- 0.2126 * R_norm + 0.7152 * G_norm + 0.0722 * B_norm
    
    return(Y)
}

process_file <- function(file) {
  sample_path = generate_sample(file)
  grays = get_grays(sample_path)
  
  number_path = tmp_path("number", file, "png")
  if (file.exists(number_path) && cache_images) {
    number_pic <- image_read(number_path)
  } else {
    number_pic = get_number_pic(file)
    image_write(number_pic, path=number_path, format="png" )
  }
  
  filename <- basename(file)
  number <- ocr_cache[[filename]]
  if (!is.integer(number)) {
    number = get_number(number_pic)
  }
  
  characters <- strsplit(toString(number), "")[[1]]
  dice <- 36 # rough size of dice in pixels
  canvas <- image_blank(1, 1)  # Initialize a blank canvas
  
  for (i in seq_along(characters)) {
    char <- characters[i]
    die <- image_blank(dice, dice, color="gray90")
    die <- image_annotate(die, char, size=30, gravity="center", font="Ubuntu" )
    canvas <- image_append(c(canvas,die))
  }
  
  ocr_comparison = image_append(c(number_pic, canvas), stack=TRUE)

  ocr_path = tmp_path("ocr", file, "png")
  image_write(ocr_comparison, path=ocr_path, format="png" )
  
  hist_path = tmp_path("hist", file, "svg")
  if (file.exists(hist_path) && cache_histograms) {
  } else {
    ggplot(data.frame(x=grays), aes(x)) + 
      expand_limits(x=0) +
      expand_limits(x=255) +
      geom_histogram(binwidth=1, color="black") + 
      scale_y_continuous(expand = expansion(mult = c(0, 0.05))) +
      scale_x_continuous(expand = expansion(mult = c(0, 0))) +
      theme_minimal() +
      theme(
        axis.title.x=element_blank(),
        axis.text.x=element_blank(),
        axis.ticks.x=element_blank(),
        axis.title.y=element_blank(),
        axis.text.y=element_blank(),
        axis.ticks.y=element_blank(),
        panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(),
        panel.background = element_rect(fill = "gray90", color = "gray90")
        # panel.border = element_rect(color = "black", fill = NA, size = 0.1)
      )
    ggsave(hist_path, width=4, height=2, units="cm")
  }
      
  df <- data.frame(
    Sample = sample_path %>% pander::pandoc.image.return(),
    sample_path = sample_path,
    OCR = number,
    Filename = basename(file),
    Histogram = hist_path %>% pander::pandoc.image.return(),
    hist_path = hist_path,
    Number = number_path %>% pander::pandoc.image.return(),
    number_path = number_path,
    Pixels = length(grays),
    Average = mean(grays),
    Standard_Deviation = sd(grays),
    Max = max(grays),
    Min = min(grays),
    ocr_comparison = ocr_path %>% pander::pandoc.image.return()
  )
  
  return(df)
}
``` 

```{r build_data_frame, echo=FALSE}
files <- list.files("pictures/calibration", full.names = TRUE)
samples <- map_dfr(files, process_file)
```

```{r write_ocr_cache, echo=FALSE}
ocr_cache <- samples %>% 
  select(Filename, OCR) %>%
  arrange(OCR)
df2yaml(ocr_cache, key_col="Filename", val_col="OCR", out_yaml="ocr.yaml")
```

#### Sample Numbering

Samples are numbered using a 7 digit code using numbers 1-6 and 9.  (Six sides of a die plus 9 as an upside down 6.)

Each digit represents a specific piece of data:

1. Grid X
1. Grid Y
1. Oil
    * 1 Light Butter
    * 2 Heavy Butter
    * 3 Light Mayo
    * 4 Heavy Mayo
    * 9 None
1. State
    * 9 Uncooked
    * 1 Grilled
1. Batch Number
    * 1-6 Experiment(s)
    * 9 Calibration Tests (ignore)
1. Unassigned
    * 9 No meaning
1. Unassigned
    * 9 No meaning

#### OCR Calibration

All data is processed using numbers derived from Optical Character Recognition (OCR).  Use this section to ensure the all numbers have been identified correctly.  The top 
row is the picture of the dice (heavily filtered for better processing) and the shaded gray text is the detected number.  If there are any mistakes edit `ocr.yaml` to make corrections and re-knit this document.

Common issues:

* Number oriented incorrectly
* Reflection detected as a 1
* Number on front of die detected

```{r ocr_calibration, echo=FALSE}
samples %>% 
  arrange(OCR) %>%
  select(Filename, ocr_comparison) %>%
  pander()
```



### H
```{r include=FALSE}
# Describe your experimental procedure in enough detail that a reader would be able to replicate the experiment.
```

## Section IV: Result

### I
```{r include=FALSE}
# Summarize the quantitative data gathered from each experimental manipulation. Be sure to highlight the key findings and trends.
```

```{r data_table}
samples %>% 
  select(
    Sample,
    Histogram, 
    Min,
    Max,
    Average, 
    Standard_Deviation
  ) %>%
  arrange(Average) %>%
  pander(split.table=Inf)
```


### J
```{r include=FALSE}
# Create a visual representation (i.e., data table, graph, chart) for the data you gathered from each experimental manipulation. Be sure that you choose a method of visual representation that effectively communicates the main findings of your experiment (e.g., exact measurements, trends over time, differences across categories, proportions). Make sure your visual representation clearly represents data for each quantified variable, and be sure to label and align your data accurately. Remember also to choose a scale that fits the range of the data and represent your data points precisely and accurately.
```
 

## Section V: Conclusions
 

### K
```{r include=FALSE}
# Discuss whether your hypothesis(es) was confirmed, refuted, or partially confirmed. Be sure to describe the observed results supporting your conclusion.
```

### L
```{r include=FALSE}
# Describe at least one uncontrolled, confounding variable that could have influenced your observed results and any ways the experiment could be improved.
```
 
### M
```{r include=FALSE}
# Discuss how your experimental results relate to the references presented in the literature review.
```

## Section VI: Sources
### N
```{r include=FALSE}
# Acknowledge sources, using in-text citations and references, for content that is quoted, paraphrased, or summarized.
```

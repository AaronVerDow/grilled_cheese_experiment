---
title: Grilled Cheese Experiment
output:
  html_document: default
  pdf_document: default
---
## Section I: Introduction and Literature Review

```{r imports, echo=FALSE, results='hide', message=FALSE}
library(magick)
library(tesseract)
library(knitr)
library(dplyr)
library(pander)
library(purrr)
library(tidyverse)
library(svglite)
library(yaml)
library(df2yaml)
library(tidyr)
```

### A
```{r include=FALSE}
# Summarize how at least two reference materials relate to the basic scientific principles of your experiment. Each reference material must come from a different source. Be sure to describe how the references provide a foundational background for the experiment you will conduct.
```

## Section II: Hypothesis

### B

```{r include=FALSE}
# Make a hypothesis(es) to predicit the effect of a manipulation of an independent variable on a quantitative dependent variable.
```

### C

```{r include=FALSE}
# Justify your hypothesis(es) based on prior research and known scientific principles.
```

## Section III: Method

### D
```{r include=FALSE}
# Describe the independent variable(s); include the following information:
# * a description of how the variable(s) will be manipulated
# * description of experimental conditions, if applicable
```

#### Grid
```{r grid}
oils = character(0)
oils_short = character(0)

# explicitly assigning numbers so the assignments never change
oils[1] = "Light Butter"
oils_short[1] = "LB"

oils[2] = "Light Mayo"
oils_short[2] = "LM"

oils[3] = "None"
oils_short[3] = "X"

oils[4] = "Heavy Butter"
oils_short[4] = "HB"

oils[5] = "Heavy Mayo"
oils_short[5] = "HM"

pander(matrix(oils_short, ncol=6, nrow=5, byrow=TRUE),  split.table=Inf)

grid <- data.frame(
  x = rep(1:6, times=5),
  y = rep(1:5, each=6),
  oil_num = rep(1:5)
)

grid <- mutate(grid,
  oil = oils[oil_num],
  id = x*100 + y*10 +oil_num
)

pander(grid)
```


### E: Dependent Variables
```{r include=FALSE}
# Describe the dependent variable(s); include the following information:
# * a description of how the variable(s)will be quantified, including units of measure
# * a description of how the variable(s) will be recorded
# The dependent variable is the darkness of the bread.  This will be measured by photographing each sample in a box with a controlled light source and checking the average value of the pixels.
```

### F
```{r include=FALSE}
# Describe at least one external, confounding variable and how it will be controlled. Be sure to justify how your method of controlling that variable will mitigate any confounding effect on observed results.
```
 
### G
```{r include=FALSE}
# Describe your materials and measurement tools in enough detail that a reader would be able to replicate the experiment.
```

#### Software setup

See GitHub repository https://github.com/AaronVerDow/grilled_cheese_experiment/

#### GoPro setup

#### Image Tests

```{r constants, echo=FALSE, results='hide', message=FALSE}
CACHE_IMAGES <- FALSE
CACHE_HISTOGRAMS <- TRUE && CACHE_IMAGES

# open picture in GIMP, select area, use position and size values
# (take screenshot of this)
SAMPLE_GEOMETRY <- "662x746+1564+1822"
ID_GEOMETRY <- "243x1674+3372+1413"

# adjust light cutoff for rendering numbers as black and white
ID_THRESHOLD <- "85%"

# scaling to shrink photograph of ID
# target value for tesseract is 32 px high letters
ID_SCALE <- "250"

# options for fake rendering of dice for OCR comparison
DIE_SIZE <- 36 # rough size of dice in pixels
DIE_FONT_SIZE <- 30
DIE_FONT <- "Ubuntu"

OCR_CACHE_PATH <- "ocr.yaml"
OCR_CACHE <- yaml.load_file(OCR_CACHE_PATH)
```

```{r functions, echo=FALSE, results='hide', message=FALSE}

generate_sample <- function(path) {
  sample_path = tmp_path("sample", path, "png")
  if (!file.exists(sample_path) || !CACHE_IMAGES) {
    image_read(path) %>%
    process_sample_pic() %>%
    image_write(path=sample_path, format="png")
  }
  return(list(
    path=sample_path
  ))
}

process_sample_pic <- function(image) {
    image %>%
        crop_sample() %>%
        chromakey() %>%
        image_modulate(saturation = 0)
}

crop_sample <- function(image) {
  image %>%
      image_crop(SAMPLE_GEOMETRY)
}

chromakey <- function(image) {
  pixels <- image_data(image, channels = "rgba")

  red <- pixels[1,,]
  green <- pixels[2,,]
  blue <- pixels[3,,]

  mask <- (green > red) & (green > blue)

  pixels[4,,][mask] <- as.raw(0)
  
  return(image_read(pixels))
}

get_grays <- function(path) {
    # returns a vector of opaque values
    # image is assumed to be grayscale with rgba channels
    pixels <- image_read(path) %>% image_data(channels="rgba")
    gray <- as.numeric(pixels[1,,])
    alpha <- as.numeric(pixels[4,,])
    mask <- alpha != 0
    return(gray[mask])
}

generate_id <-function(photo) {
  path = tmp_path("id", photo, "png")
  if (!file.exists(path) || !CACHE_IMAGES) {
    image_read(photo) %>%
        process_number_pic() %>%
        image_write(path=path, format="png")
  }

  id <- cached_ocr(path)

  return(list(
    path = path,
    id = id,
    comparison = ocr_comparison(id, path, photo)
  ))
}

process_number_pic <- function(image) {
  image %>% 
    image_crop(ID_GEOMETRY) %>%
    image_rotate(90) %>%
    image_reducenoise() %>%
    image_modulate(saturation = 0) %>%
    image_threshold(type="white", threshold=ID_THRESHOLD)  %>%
    image_threshold(type="black", threshold=ID_THRESHOLD)  %>%
    image_negate() %>%
    # target 32px for letter height
    image_scale(ID_SCALE)
}

cached_ocr <- function(path) {
  # use a cache so values can be corrected
  id <- OCR_CACHE[[path]]
  if (!is.integer(id)) {
    id = dice_ocr(path)
  }
  return(id)
}

dice_ocr <- function(path) {
  # https://cran.r-project.org/web/packages/tesseract/vignettes/intro.html
  # 9 is an upside down 6
  image = image_read(path)
  dice <- tesseract(options = list(tessedit_char_whitelist = "1234569"))
  as.integer(tesseract::ocr(image, engine = dice))
}

fake_dice <- function(id) {
  # makes an image of id roughly the same size as photo for comparison
  canvas <- image_blank(1, 1)  # Initialize a blank canvas
  chars <- strsplit(toString(id), "")[[1]]
  for (i in seq_along(chars)) {
    die <- image_blank(DIE_SIZE, DIE_SIZE, color="gray90") %>% 
      image_annotate(chars[i], size=DIE_FONT_SIZE, gravity="center", font=DIE_FONT )
    canvas <- image_append(c(canvas,die))
  }
  return(canvas)
}

# I'd like to tidy up this interface later
ocr_comparison <- function(id, id_path, file_path) {
  id_pic <- image_read(id_path)
  canvas <- fake_dice(id)
  ocr_path = tmp_path("ocr", file_path, "png")
  image_append(c(id_pic, canvas), stack=TRUE) %>%
    image_write(path=ocr_path, format="png" )
  return(ocr_path)
}

generate_histogram <- function(grays, path) {
  path = tmp_path("histogram", path, "png")
  if (!file.exists(path) || !CACHE_HISTOGRAMS) {
    ggplot(data.frame(x=grays), aes(x)) + 
      expand_limits(x=0) +
      expand_limits(x=255) +
      geom_histogram(binwidth=1, color="black") + 
      scale_y_continuous(expand = expansion(mult = c(0, 0.05))) +
      scale_x_continuous(expand = expansion(mult = c(0, 0))) +
      theme_minimal() +
      theme(
        axis.title.x=element_blank(),
        axis.text.x=element_blank(),
        axis.ticks.x=element_blank(),
        axis.title.y=element_blank(),
        axis.text.y=element_blank(),
        axis.ticks.y=element_blank(),
        panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(),
        panel.background = element_rect(fill = "gray90", color = "gray90")
      )
    ggsave(path, width=4, height=2, units="cm")
  }
  return(list(
    path=path
  ))
}

tmp_path <- function(prefix, path, extension) {
  path <- basename(path)
  path <- gsub("[^/.]*$", extension, path)
  path <- paste(prefix, path, sep="_")
  paste("tmp", path, sep="/")
}

process_file <- function(file) {
  sample = generate_sample(file)
  grays = get_grays(sample$path)
  id = generate_id(file)
  histogram = generate_histogram(grays, file)
     
  df <- data.frame(
    Sample = sample$path %>% pandoc.image.return(),
    sample_path = sample$path,
    OCR = id$id,
    Filename = basename(file),
    Histogram = histogram$path %>% pandoc.image.return(),
    Number = id$path %>% pandoc.image.return(),
    Pixels = length(grays),
    Average = mean(grays),
    Standard_Deviation = sd(grays),
    Max = max(grays),
    Min = min(grays),
    ocr_comparison = id$comparison %>% pandoc.image.return()
  )
  
  return(df)
}
``` 

```{r build_data_frame, echo=FALSE}
files <- list.files("pictures/calibration", full.names = TRUE)
samples <- map_dfr(files, process_file)
```

```{r write_ocr_cache, echo=FALSE}
ocr_cache <- samples %>% 
  select(Filename, OCR) %>%
  arrange(OCR)
df2yaml(ocr_cache, key_col="Filename", val_col="OCR", out_yaml=OCR_CACHE_PATH)
```

#### Sample Numbering

Samples are numbered using a 7 digit code using numbers 1-6 and 9.  (Six sides of a die plus 9 as an upside down 6.)

Each digit represents a specific piece of data:

1. Grid X
1. Grid Y
1. Oil
    * 1 Light Butter
    * 2 Heavy Butter
    * 3 Light Mayo
    * 4 Heavy Mayo
    * 9 None
1. State
    * 9 Uncooked
    * 1 Grilled
1. Batch Number
    * 1-6 Experiment(s)
    * 9 Calibration Tests (ignore)
1. Unassigned
    * 9 No meaning
1. Unassigned
    * 9 No meaning

#### OCR Calibration

All data is processed using numbers derived from Optical Character Recognition (OCR).  Use this section to ensure the all numbers have been identified correctly.  The top 
row is the picture of the dice (heavily filtered for better processing) and the shaded gray text is the detected number.  If there are any mistakes edit `ocr.yaml` to make corrections and re-knit this document.

Common issues:

* Number oriented incorrectly
* Reflection detected as a 1
* Number on front of die detected

```{r ocr_calibration, echo=FALSE}
samples %>% 
  arrange(OCR) %>%
  select(Filename, ocr_comparison) %>%
  pander()
```



### H
```{r include=FALSE}
# Describe your experimental procedure in enough detail that a reader would be able to replicate the experiment.
```

## Section IV: Result

### I
```{r include=FALSE}
# Summarize the quantitative data gathered from each experimental manipulation. Be sure to highlight the key findings and trends.
```

```{r data_table}
samples %>% 
  select(
    Sample,
    Histogram, 
    Min,
    Max,
    Average, 
    Standard_Deviation,
    Pixels
  ) %>%
  arrange(Average) %>%
  pander(split.table=Inf)
```


### J
```{r include=FALSE}
# Create a visual representation (i.e., data table, graph, chart) for the data you gathered from each experimental manipulation. Be sure that you choose a method of visual representation that effectively communicates the main findings of your experiment (e.g., exact measurements, trends over time, differences across categories, proportions). Make sure your visual representation clearly represents data for each quantified variable, and be sure to label and align your data accurately. Remember also to choose a scale that fits the range of the data and represent your data points precisely and accurately.
```
 

## Section V: Conclusions
 

### K
```{r include=FALSE}
# Discuss whether your hypothesis(es) was confirmed, refuted, or partially confirmed. Be sure to describe the observed results supporting your conclusion.
```

### L
```{r include=FALSE}
# Describe at least one uncontrolled, confounding variable that could have influenced your observed results and any ways the experiment could be improved.
```
 
### M
```{r include=FALSE}
# Discuss how your experimental results relate to the references presented in the literature review.
```

## Section VI: Sources
### N
```{r include=FALSE}
# Acknowledge sources, using in-text citations and references, for content that is quoted, paraphrased, or summarized.
```
